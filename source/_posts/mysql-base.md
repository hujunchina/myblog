---
title: MySQL及数据库知识点
date: 2020-10-23 21:30:57
categories:
	- 基础知识
tags:
	- 编程
	- 数据库
	- MYSQL
---

# 1. 数据库CURD

包含数据库基本操作语句，对管理权限、用户等管理。

## 1.1 用户管理

用户表在数据库msql的user表中。MysQL用户根据授予的权限担任不同的角色。比如某用户只能对一个表进行操作等。

使用数据库和表可以直接用命令 `use +table|database`

### 1.1.1 创建用户

Mysql存储用户的表在 `mysql.user`

`create user hujun identified by 123456`

创建用户hujun，密码为123456

### 1.1.2 设置密码

可以使用更新语句：`update mysql.user set password=password('123456') where user=hujun`

user表中保存密码默认加密方式，MD5或SHA1等，使用password函数设置。

### 1.1.3 修改用户

`update mysql.user set user='hujun' where user='hujun'`

使用更新语句直接设置即可。

## 1.2 权限管理

MySQL的权限可分为select、insert、delete、update等。在命令中设置的用户仅对某张表起作用。

### 1.2.1 授予权限

`grant select, insert, delete, update on books to hujun@localhost`

使用命令 grant 授予，通过介词 on 表示在那个数据库中，介词 to 表示给哪个用户。

### 1.2.2 收回权限

`revoke all privileges on books from hujun@localhsot`

## 1.3 七种Join

```mysql
SELECT <ROW-LIST>
	FROM <LEFT-TABLE>
	<INNER | LETT | RIGHT> JOIN <RIGHT-TABLE>
		ON <JOIN-CONDITION>
			WHERE <WHERE-CONDITION>
```

执行顺序（**SQL语句里第一个被执行的总是FROM子句**）：

- **FROM**:对左右两张表执行笛卡尔积，产生第一张虚拟表vt1。行数为n*m（n左表的行数，m右表的行数）
- **ON**:根据ON的条件逐行筛选vt1，将结果插入vt2中
- **JOIN**:添加外部行，如果指定了**LEFT JOIN**(**LEFT OUTER JOIN**)，则先遍历一遍**左表**的每一行，其中不在vt2的行会被插入到vt2，该行的剩余字段将被填充为**NULL**，形成vt3；如果指定了**RIGHT JOIN**也是同理。但如果指定的是**INNER JOIN**，则不会添加外部行，上述插入过程被忽略，vt2=vt3（所以**INNER JOIN**的过滤条件放在**ON**或**WHERE**里 执行结果是没有区别的，下文会细说）
- **WHERE**:对vt3进行条件过滤，满足条件的行被输出到vt4
- **SELECT**:取出vt4的指定字段到vt5

### 1.3.1 执行顺序案例

创建用户信息表和用户余额表：

```mysql
CREATE TABLE `user_info`(
    `userId` int(11) not null,
    `name` varchar(255) not null,
    UNIQUE `userId`(`userId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE `user_account`(
    `userId` int(11) not null,
    `money` bigint(20) not null,
    UNIQUE `userId`(`userId`)
) ENGING=InnoDB DEFAULT CHARSET=utf8mb4
```

导入数据：

| userId | 1    | 2    | 3    | 4    | 5    |
| ------ | ---- | ---- | ---- | ---- | ---- |
| name   | a    | b    | c    | d    | e    |

| userId | 1    | 2    | 3    | 9    |
| ------ | ---- | ---- | ---- | ---- |
| money  | 100  | 200  | 300  | 400  |

取出userid为1003的用户姓名和余额，SQL如下:

```mysql
SELECT U.NAME, A.MONEY
	FROM `user_info` AS U
		LEFT JOIN `user_account` AS A
			ON U.userId = A.userId
				WHERE A.userID=3
```

#### 1.3.1.1 第一步 from

笛卡尔积操作后会返回两张表中所有行的组合，左表userinfo有5行，右表useraccount有4行，生成的虚拟表vt1就是5*4=20行：

| userId | 1    | 2    | 3    | 4    | 5    | 1    | 2    | 3    | 4    | 5    | 1    | 2    | 3    | 4    | 5    | 1    | 2    | 3    | 4    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| name   | a    | b    | c    | d    | e    | a    | b    | c    | d    | e    | a    | b    | c    | d    | e    | a    | b    | c    | d    |
| userId | 1    | 1    | 1    | 1    | 1    | 2    | 2    | 2    | 2    | 2    | 3    | 3    | 3    | 3    | 3    | 9    | 9    | 9    | 9    |
| money  | 1    | 1    | 1    | 1    | 1    | 2    | 2    | 2    | 2    | 2    | 3    | 3    | 3    | 3    | 3    | 4    | 4    | 4    | 4    |

from 会直接把两个表中的数据做一一映射，即笛卡尔积。

#### 1.3.1.2 第二步 on

执行ON子句过滤掉不满足条件的行，`ON U.userId = A.userId`，得到第二个虚拟表vt2：

| userId | 1    | 2    | 3    |
| ------ | ---- | ---- | ---- |
| name   | a    | b    | c    |
| userId | 1    | 2    | 3    |
| money  | 100  | 200  | 300  |

from 做了两个表的笛卡尔积，就确保了无论是什么类型join，所有可能情况都在表中，所以可以直接先判断on的条件，不用join。

#### 1.3.1.3 第三步 join

**LEFT JOIN**会将左表未出现在vt2的行插入进vt2，每一行的剩余字段将被填充为NULL，**RIGHT JOIN**同理。

本例中用的是**LEFT JOIN**，所以会将左表**user_info**剩下的行都添上 生成表vt3：

| userId | 1    | 2    | 3    | 4    | 5    |
| ------ | ---- | ---- | ---- | ---- | ---- |
| name   | a    | b    | c    | e    | f    |
| userId | 1    | 2    | 3    | NULL | NULL |
| money  | 100  | 100  | 100  | NULL | NULL |

left join 就是把左表出现的键值全部连接进虚拟表中；right join 就是把右表所有主键连接到虚拟表中；inner join 需要把左右表共有部分（交集）连接到虚拟表中。

如果直接看实绩表，left join 表现效果就是以左表主键为主建立连接，右表有主键而左表没有的直接舍去；右表没有的而左表有的直接置NULL。 

#### 1.3.1.4 第四步 where

WHERE a.userid = 3 生成表vt4：

| userId | name | userId | money |
| ------ | ---- | ------ | ----- |
| 3      | c    | 3      | 300   |

#### 1.3.1.5 第五步 select

最后 select 会选择需要的列字段返回为结果，虚拟表vt5：

| name | money |
| ---- | ----- |
| c    | 300   |

### 1.3.2 三种 Join 区别

- **INNER JOIN...ON...**: 返回 左右表互相匹配的所有行（因为只执行上文的第二步ON过滤，不执行第三步 添加外部行）
- **LEFT JOIN...ON...**: 返回左表的所有行，若某些行在右表里没有相对应的匹配行，则将右表的列在新表中置为NULL
- **RIGHT JOIN...ON...**: 返回右表的所有行，若某些行在左表里没有相对应的匹配行，则将左表的列在新表中置为NULL

注意，MySQL 没有 FULL JOIN 所以需要通过left+right+union来实现。 

### 1.3.3 交集 inner join A on B

```mysql
SELECT U.NAME, A.MONEY
	FROM `user_info` as U
		INNER JOIN `user_account` as A
			ON A.userId = U.userId
				WHERE A.userId = 3;
```

交集只会在 on 这一步停下来，不会去 join 了，所以有时候缩写 `inner on` 。即不会把左表或右表的所有行都映射到虚拟表中。

### 1.3.4 左连 left join A on B

```mysql
SELECT U.NAME, A.MONEY
	FROM `user_info` as U
		LEFT JOIN `user_account` as A
			ON A.userId = U.userId
				WHERE A.userId = 3;
```



### 1.3.5 右连 right join A on B

```mysql
SELECT U.NAME, A.MONEY
	FROM `user_info` as U
		RIGHT JOIN `user_account` as A
			ON A.userId = U.userId
				WHERE A.userId = 3;
```



### 1.3.6 左表独有

```mysql
SELECT U.NAME, A.MONEY
	FROM `user_info` as U
		LEFT JOIN `user_account` as A
			ON A.userId = U.userId
				WHERE A.userId IS NULL;
```



### 1.3.7 右表独有

```mysql
SELECT U.NAME, A.MONEY
	FROM `user_info` as U
		RIGHT JOIN `user_account` as A
			ON A.userId = U.userId
				WHERE U.userId IS NULL;
```



### 1.3.8 全连 full join

```mysql
SELECT U.NAME, A.MONEY
	FROM `user_info` as U
		LEFT JOIN `user_account` as A
			ON A.userId = U.userId
				WHERE A.userId = 3
UNION
SELECT U.NAME, A.MONEY
	FROM `user_info` as U
		RIGHT JOIN `user_account` as A
			ON A.userId = U.userId
				WHERE A.userId = 3;
```



### 1.3.9 独立部分并

```mysql
SELECT U.NAME, A.MONEY
	FROM `user_info` as U
		LEFT JOIN `user_account` as A
			ON A.userId = U.userId
				WHERE A.userId IS NULL
UNION
SELECT U.NAME, A.MONEY
	FROM `user_info` as U
		RIGHT JOIN `user_account` as A
			ON A.userId = U.userId
				WHERE U.userId IS NULL;
```

## 1.4 DDL 表操作

- 设置自增 `alter table kunlun_role modify id int auto_increment`
- 设置自动时间 `ALTER TABLE course
  MODIFY COLUMN create_time datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间' ;`

### 1.4.1 时间函数

- `select unix_timestamp(now());`  1584524789
- `select unix_timestamp();` 1584524524
- `select now();`  2020-03-18 17:39:13
- `select date(now());` 2020-03-18
- `select unix_timestamp('2018-01-15 09:45:16');`   1515980716
- `select from_unixtime(1515980716);`  2018-01-15 09:45:16
- `SELECT from_unixtime(1515980716, '%Y-%m-%d %H:%i:%S');` 2018-01-15 09:45:16     
- `select date_format(now(), '%Y-%m-%d');`  2020-03-18

关于按日期统计数量：使用一个函数和分组即可

```sql
SELECT count(device_id), from_unixtime(gmt_create/1000, '%Y-%m-%d') days
FROM device
WHERE status = 1 AND online_status=1
GROUP BY days;
```



# 2. 范式

## 2.1 基础知识

**主键为候选键的子集，候选键为超键的子集，而外键的确定是相对于主键的**

### 2.1.1 视图是什么

视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。

视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有 order by ，则对视图再次 order by 将被覆盖。

## 2.2 第一范式

在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。

 所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。

如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。

简而言之，**「第一范式就是无重复的列」**。

## 2.3 第二范式

第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。 

第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。

简而言之，**「第二范式就是非主属性非部分依赖于主关键字」**。

## 2.4 第三范式

满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。

例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。

简而言之，**第三范式就是属性不依赖于其它非主属性**。

# 3. 数据库索引

MySQL的存储引擎都是支持索引的，只是对索引的建立和使用有区别，但第二层的解析器对语法的规定是相同的，这样可以实现对底层的隔离。

```mysql
CREATE INDEX index_name
	ON table_name(column_name1, column_name2);
```

索引底层使用 B+ 树实现，需要占用空间存储数据，根据树特定对键值进行排序。

那么在查询的时候可以以 logN 速度找到结果。

## 3.1 一个测试

### 3.1.1 建表和插入数据

```mysql
create table books(
  id int not null primary key auto_increment,
  name varchar(255) not null,
  author varchar(255) not null,
  created_at datetime not null default current_timestamp,
  updated_at datetime not null default current_timestamp on update current_timestamp
)engine=InnoDB;
```

MySQL 关键字 `primary key` 自增形式 `auto_increment`，时间类型用 `datetime` ，还有一个提供当前时间的函数 `current_timestamp`。

```mysql
drop procedure prepare_data;
delimiter //
create procedure prepare_data()
begin
  declare i int;
  set i = 0;
  while i < 1000000
    do
      insert into books(name, author) value (concat('name', i), concat('author', i));
      set i = i + 1;
    end while;
end //
delimiter ;
call prepare_data();
```

插入数据使用了 SQL 语法（存储过程）定义了一个 prepare_data 的函数。

由于 MySQL 默认是 ；结尾，首先要通过关键字 `delimiter` 指定新的结尾 `//` 。然后就是声明函数、开始、定义变量、循环插入、结束，最后是调用函数。

### 3.1.2 统计查询

进入information_schema 数据库。

```mysql
select table_rows, data_length from tables where table_schema='test';
```

查询新建的表中记录的个数和数据大小。

```mysql
set profiling = 1;
select * from books where name = 'name900000';
show profiles;
set profiling = 0;
```

在不使用索引的情况下，每个查询大概 160ms 左右。

如何统计时间？`set profiling=1` 打开统计信息； `show profiles` 查看执行统计包括时间。profiling 名称，资料收集的作用。

### 3.1.3 优化为索引

```mysql
create index idx_books_name on books(name);
```

100万条数据，建立索引用时 8.68 秒，然后使用索引查询用时 3ms 左右，比不用索引提高了近50倍。

可以使用 `explain` 关键字查看是否语句走了索引。

## 3.2 索引知识

### 3.2.1 主索引

通常是对每一个存储块有一个索引项，且索引项总数 和 存储块数目相同的。这样的索引叫做主索引。

存储表的每一存储块的第一条记录，又称为锚记录。

主索引的索引字段值为块锚的索引字段值，而指针指向其所在的存储块。

存储块可以存储多条记录，如从1～10条记录，第一条叫做锚记录，也是该块索引的标记值。

![image-20201025153427533](/images/mysql01.png)

### 3.2.2 辅助索引

是定义在主文件的任一个或多个非排序字段的辅助存储结构。

主索引建立在主码或排序吗上面，而辅助索引建立在其他属性上面。

一个主文件仅有一个主索引，但可以有多个辅助索引。

可以利用主索引重新建立组织主文件数据，但辅助索引不能改变主文件数据。

### 3.2.3 聚簇索引

指索引中邻近的记录在主文件中也是临近存储的，每个存储块的记录的T#在聚簇文件中都是一样的。

如果主文件的某个排序字段不是主码，每个记录不唯一，为聚簇字段。

一个主文件只能有一个聚簇索引，可以有多个非聚簇索引。

因此，主索引通常是聚簇索引，辅助索引通常是非聚簇索引。

聚簇索引是能够决定记录存储位置的索引，非聚簇索引则只能查询，指出已存在记录位置。

### 3.2.4 非聚簇索引

### 3.2.5 倒排索引

正常索引是，一个文件有哪些词汇，而倒排索引则是一个词汇在那些文件中。

### 3.2.6 其他索引

多级索引（对索引再建立索引）

多属性索引（多个属性组成一个索引）

散列索引（以散列形式存储关键字）

网格索引（使用索引字段进行交叉联合定位与检索）

### 3.2.7索引的最左匹配原则

最左匹配原则：触发多级索引，要按照索引key顺序构建条件筛选过滤。因为建立重复索引是有序的，在左边的要作为第一个匹配来用，如果第一个无法匹配就不走索引了，所以必须要满足最左匹配原则才能走索引。

如index(price, name) 查询不能只找name，那样和不用索引一样，要加上price查询。

那么当建立的索引是重复大选择性低的列时如SEX，如何强制走索引呢？

```mysql
SELECT U.NAME FROM USER WHERE NAME='H' AND SEX IN ('M','F')
```

上面使用了 in 范围操作来强制走索引，因为 sex 只能在 M和F 一个，会包含所有可能，不会再出索引了。

### 3.2.8 索引构建条件

现建立一个索引为 INDEX(PRICE, NAME)，对 WHERE 构建是有条件的：

- where price + name 可以走索引
- where name + price 可以走索引，mysql 优化器会优化为和上面一样
- where price 可以走索引，一级索引可以用
- where name 不能走索引， 二级索引不能用，不满足最左匹配原则

### 3.2.9 优化及防止回表

我们可以对 SELECT 的字段都建立在索引上，形成一个覆盖索引，即要查询的结果都能在索引上找到，这样就不用再回表到聚簇索引查询。

一般在索引上查找到主键值，然后利用这个主键值到聚簇索引二次查找到结果并返回。我们把所有结果都放在索引上，形成覆盖索引，可以防止回表查询。

## 3.3 索引底层

### 3.3.1 索引原理

索引会把字段拿出来新建一个表，这个表只有主键值和该字段。表不带其他字段防止加载内存耗时。索引新建的表会按照字段排序，所以二分查找 logN 时间。查找到字段后，返回字段 主键值，根据这个主键值再找其他字段，这个过程叫回表！

MyISAM，**「B+Tree叶节点的data域存放的是数据记录的地址」**，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读区相应的数据记录，这被称为“非聚簇索引”

InnoDB，其数据文件本身就是索引文件，相比MyISAM，**「索引文件和数据文件是分离的」**，**「其表数据文件本身就是按B+Tree组织的一个索引结构，树的节点data域保存了完整的数据记录」**，这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引”或者聚集索引，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方，在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

### 3.3.2 存储

机械硬盘读取数据分为两过程：1. 寻址（10ms）2. 读取（0.01ms），可见寻址占用了大量时间。所以InnoDB做了优化，先把关联数据连续存储；再使用预加载预读功能，加载相邻地址的数据到内存。

数据分块存储，每块16KB，数据块又分层存储，按照键的大小构成一个B+树。节点是m长度的数组，子节点是父节点键大小范围内的键。

### 3.3.3 B+树索引

一个存储块为4096字节，索引整型值占4字节、指针占8字节，一共可以存储多少索引项（记录）？

4(n-1)+8n<=4096, n=341

涉及到索引的结构，其B+树在磁盘中存储结构如下：

![image-20201025163834375](/images/mysql02.png)

指针项比数字值项多一个，因为每个索引要包含左右两个结束指针。

### 3.3.4 B树索引

索引字段值仅出现一次，或者在叶子结点或者在非叶子结点。

指针（指向主文件）可出现在叶子结点或者非叶子结点，所以准确的说法是非叶子结点也可以有指向主文件或记录的指针，而不是直接说非叶子结点存储记录。

因为B树有指向主文件的指针，占用了存储块，所以其没有B+树存储的索引项多。

### 3.3.5 InnoDB 索引

#### 3.3.5.1 聚簇索引

主键构成的B+树，id等；非叶节点只有id属性；叶节点存放id行所有信息。

#### 3.3.5.2 二级索引

索引行构成B+树，可以是price，name等多个；非叶节点和叶节点都存储的索引整行信息；其实一个索引键+必须的id主键，就至少是两个。

#### 3.3.5.3 执行顺序

先在二级索引中找到name1000对应的主键id；然后回表，在聚簇索引中找到此di对应的记录；最后返回所有选择的字段。

id主键的长度越小越好，id短，数据块即节点存储的id越多，这样树的层次越少，查找效率高。保证id值是递增的，不会导致页分裂。where 条件里用不到的字段不创建索引。数据重复且分布平均的表字段不建索引。

## 3.4 索引的优化

### 3.4.1 性能下降解析

性能下降 SQL 执行时间长 ：

-  查询数据过多（拆分字段，条件过滤少）
-  Join 过多（先过滤再关联）
-  没有用索引
-  服务器调优

### 3.4.2 优化操作规则

- WHERE 语句要对字段全值匹配
- 最左前缀匹配原则
- 不在索引列做任何操作，如计算，函数，类型转换
- where条件范围多时，无法使用右边范围做索引
- 尽量覆盖索引，减少select *
- 不等于操作无法使用索引，导致全表扫描
- is not null 无法使用索引，is null可以
- like '%xx' 无法使用索引
- 字符串不加单引号，索引失效 
- or 会使索引失效

## 3.5 大表优化

查询时限定数据范围；读写分离，主库负责写，从库负责读；垂直分区，以主键分为多个表；水平分区，分片数据表，1~1w一个表；

### 3.5.1 分表后如何保证ID的全局唯一性

	1. UUID 不能太长且不自增
	2. 数据库自增id，不行需要独立部署数据库防止重复
	3. redis 生成id， 需要用到redis
	4. Twitter的snowflake算法
	5. 美团的Leaf分布式ID生成系统

### 3.5.2 结构优化

**「范式优化」**： 比如消除冗余（节省空间。。）

**「反范式优化」**：比如适当加冗余等（减少join）

**「限定数据的范围」**： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。

**「读/写分离」**： 经典的数据库拆分方案，主库负责写，从库负责读；

**「拆分表」**：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。

### 3.5.3 对表的拆分

- 垂直拆分：解决表与表之间的 IO 竞争问题。不能解决数据量增长的压力。把不同表放在不同的主机上。
- 水平拆分：解决数据量增长的压力。

方案：**「用户表」** 通过性别拆分为男用户表和女用户表，**「订单表」** 通过已完成和完成中拆分为已完成订单和未完成订单，**「产品表」** 未完成订单放一个server上，已完成订单表和男用户表放一个server上，女用户表放一个server上。

## 3.6 如何设计索引

设计索引要考虑每列的两个因素：频繁度和选择性。

频繁度就是使用的程度，select 经常查询的列就是频繁的。

选择性就是该列的离散程度、字段的重复程度。

频繁使用的列但是选择性差的，比如性别，也是可以作为索引的。

# 4. 存储引擎

MySQL存储引擎可分为 InnoDB 和 MyISAM 两种，还有其他第三方引擎等多种。

数据库是分层设计的，最上层服务应用和数据库共有的，包括连接处理、授权认证、安全等。第二层是服务模块，包括查询缓存、解析器、优化器等；重要的数据库特性都在这一层，包括存储过程、触发器、视图等。

第三层是存储引擎，负责数据的存储和读取，并向上暴露服务API。

MySQL 会为每个数据库创建一个目录，并在目录中创建和表同名的 `.frm` 文件用于保存表的定义。

我们可以通过 `show table status` 查看表的定义，和这个表使用了什么存储引擎。

## 4.1 MyISAM

MySQL 旧版本默认的存储引擎，提供了全文索引、压缩表、空间函数等。不支持事务和行级锁，且无法在崩溃后安全恢复。

### 4.1.1 存储

存储两个文件：`.myd` 表示数据文件和 `.myi` 表示索引文件。

### 4.1.2 特性

#### 4.1.2.1 加锁与并发

MyISAM 会对整张表加锁，即所谓的表锁，颗粒度很大，会严重降低并发量。读取时对表加共享锁，写入时对表加排他锁。故当表读取时，可以向表中插入新的记录。

可以用于非用户表的存储，比如数据库的信息表，可以用MyISAM存储引擎。

#### 4.1.2.2 修复

`check table mytable` 检查表的错误；

`repair table mytable` 修复错误。

#### 4.1.2.3 索引特性

可以支持全文索引（基于分词创建实现的索引），但不支持聚簇索引等。底层使用的是B树。

### 4.1.3 压缩表

如果插入的数据，不会在进行修改操作，适合MyISAM的压缩表特性。可以极大的减少磁盘占用，可以提升查询性能，可以支持只读索引。

### 4.1.4 性能

对存储很友好，把数据以紧凑的格式存储并压缩，适用于存档数据存储，比如历年的账单，不会再被修改可以用MyISAM存储以减少存储空间。

但不适用与高并发和频繁修改的表，因为会对整张表加锁，很多查询都会处于 Locked 状态。

## 4.2 InnoDB

### 4.2.1 概览

InnoDB 出现的晚且是很多开发人员成果。提供排序创建索引、删除增加索引时不用复杂全表数据、大型存储类型BLOB格式等。

### 4.2.2 高并发

采用 MVCC 来支持高并发，实现了四个标准的事务隔离等级，但默认等级是 `REPEATABLE READ` 可重复读等级。并通过间隙锁来避免幻读的问题。间隙锁不仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。 

### 4.2.3 索引

InnoDB 的表都是基于聚簇索引建立的，其对主键查询性能很高。其二级索引必须包含主键列，以便回表操作。

如果索引很多的话，主键要尽可能的小。

### 4.2.4 优化

内部优化有：

- 从磁盘读取数据时采用可预测性预读
- 能够自动在内存中创建hash索引以加速读操作的自适应哈希索引
- 加速插入操作的插入缓冲区

### 4.2.4 支持事务

InnoDB 默认是支持事务的，如果语句没有指明用事务，那么也会当做事务去执行。同时，InnoDB通过一些机制支持真正的热备份。

## 4.3 区别

### 4.3.1 索引不同

MyISAM 索引叶子节点存储的是数据记录地址指针，而InnoDB叶子节点存储的是主键的值。

### 4.3.2 事务支持

MyISAM不支持事务，而InnoDB支持事务，并实现了隔离等级。

### 4.3.3 锁

MyISAM 提供的是表锁，适合高性能；InnoDB提供的是行锁，适合高并发。

# 5. 事务

事务是一组原子性的SQL查询。即使是一条简单的 select 语句也会被包装成事务去处理。

## 5.1 事务原则 ACID

- Atomaic 原子性（事务内操作要么全部成功，要么全部失败）
- Consistency 一致性（与提交有关，只要没有提交更改都无效，保证前后数据的一致性）
- Isolation 隔离性（一个事务在提交前的修改对其他事务是不可见的）
- Durability 持久性（事务一旦提交，就会永久保存）

## 5.2 数据库读写问题

数据库中多个事务在读写时，会因为隔离级别产生不同的问题，有4个问题。

- 脏读（读到另一个事务未提交的数据）
- 丢失修改（两个事务同时对一个字段写入，一个事务写会丢失无效）
- 不可重复读（一个事务第一次读后，另一个事务修改了，第二次读结果不一样）
- 幻读（另一个事务在其他事务执行的范围行中插入新数据行，会莫名其妙多出数据，形成幻觉）

## 5.3 事务的隔离级别

隔离性很复杂，比较低的隔离性并发性更高，系统开销也低。隔离级别为了解决读写问题保证事务原则。

- 未提交读（事务还没有提交就读了，完全不隔离，导致所有问题，比如脏读）
- 提交读（事务提交后读，导致不可重复读和幻读）
- 可重复读（同一事务多次读取保证数据相同，导致幻读）（InnoDB通过MVCC解决了幻读）
- 可串行化（读取的每一行数据都加锁，可能导致大量超时和锁争用）

# 6. 锁和MVCC

锁和mvcc都属于数据库并发控制，在提高并发性的同时保证数据的ACID原则。MySQL在并发控制上很复杂，每种存储引擎都有自己的一套锁策略和锁粒度。

## 6.1 数据库锁机制

InnoDB 采用两阶段锁定协议，在事务执行过程中随时都可以加锁，只有在commit或rollback时锁才会释放，并且所有锁都在同一时刻释放。这个加锁的过程是隐式锁定，无法控制，InnoDB根据事务隔离级别自动加锁。

InnoDB也提供了显示加锁的方式，通过语句 `lock in share mode` 或 `for update` 加排他锁。但应尽量避免使用，会影响高并发性能。

- 表锁
- 行级锁

### 6.1.2 死锁问题

当两个事务交替对两个记录修改时，会发生死锁。InnoDB 策略是将持有最少行级排他锁的事务进行回滚。

## 6.2 多版本并发控制

MVCC 的实现，是通过保存数据在某个时间点的快照来实现。即对每次修改的事务，都定制一个版本作为快照名，并把当前值保存下来。这个保存并不是简单地在原记录上修改，而是重新生成一行记录，把值更新。

### 6.2.1 简化的MVCC

通过维护一个系统版本号来定义行的创建时间和过期时间，每开始一个事务，系统版本好就会自动递增。

- SELECT （该事务版本号要 》记录的创建版本号 且 《 记录的过期版本号）
- INSERT （插入新行数据记录的同时，把系统版本号也写入）
- DELETE（删除后要保存当前事务版本号作为删除标志）
- UPDATE（插入一行新记录，并保存新版本号）

这样的设计，使得大多数读操作不用加锁。

# 7. 主从复制双机热备

## 7.1 主从复制

### 7.1.1 主从复制原理

mysql数据库提供了一种主从备份的机制，其实就是把主数据库的所有的数据同时写到备份的数据库中。实现mysql数据库的热备份。

要想实现双机的热备，首先要了解主从数据库服务器的版本的需求。从数据库的数据版本可以高于主服务器数据库的版本，但是不可以低于主服务器的数据库版本。

### 7.1.2 主从复杂过程

![img](C:\code\github\java-interview\img\mysql-1.png)

主从复制一共分为三步：（只有日志而不是真实数据）

- master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events。 
- slave将master的binary log events拷贝到它的中继日志（relay log）。
- slave重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的。

由于主从复制的一些特性，为了保证数据一致，所以这里有些原则需要遵守：

- 每个slave只有一个master
- 每个slave只能有一个唯一的服务器ID
- 每个master可以有多个slave

## 7.2 主从复杂实战

# 7. 双机热备

## 7.1 双机热备原理

实现双机热备，原理其实就是做两个机器的互相主从，我们把上述步骤主从对调，然后做一遍就能实现了双机热备了。

![img](C:\code\github\java-interview\img\mysql-2.png)

## 7.2 双机热备原理

由于两台机器互为主从，当同时插入数据时，对自增的ID会出错。

要么使用非自增 UUID，但是会导致存储性能下降，产生碎片和分页过多，树深度过多等问题。

要么一台主机增加奇数键，另一台主机增加偶数键。

# 8. 数据库进阶

## 8.1 数据库查询算法

数据库查询是如何实现的？底层原理是什么？

